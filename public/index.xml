<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Literate DevOps</title>
    <link>https://literate-devops.io/</link>
    <description>Recent content on Literate DevOps</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Â© 2023 James Hilling</copyright>
    <lastBuildDate>Tue, 18 Apr 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://literate-devops.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Pod</title>
      <link>https://literate-devops.io/kubernetes/pod/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/pod/</guid>
      <description>A Pod is the smallest unit of compute within a Kubernetes cluster.
Create a pod Imperative command:
kubectl run $NAME --image=$IMAGE --labels=$LABELS --namespace=default Example manifest:
1apiVersion: v1 2kind: Pod 3metadata: 4 name: nginx 5 namespace: default 6 labels: 7 app: nginx 8spec: 9 containers: 10 - name: nginx 11 image: docker.io/library/nginx:latest 12 imagePullPolicy: Never Resource output for a pod:
kubectl get pods/$NAME --namespace=default </description>
    </item>
    
    <item>
      <title>Image pull policy</title>
      <link>https://literate-devops.io/kubernetes/image-pull-policy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/image-pull-policy/</guid>
      <description>If you wish to deploy a Kubernetes application using the images cached on the nodes, ensure that the imagePullPolicy field is set to either Never, or IfNotPresent.
Example manifest:
1apiVersion: v1 2kind: Pod 3metadata: 4 name: nginx 5 namespace: default 6 labels: 7 app: nginx 8spec: 9 containers: 10 - name: nginx 11 image: docker.io/library/nginx:latest 12 imagePullPolicy: Never </description>
    </item>
    
    <item>
      <title>ReplicationController</title>
      <link>https://literate-devops.io/kubernetes/replicationcontroller/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/replicationcontroller/</guid>
      <description>A ReplicationController is responsible for keeping the total number of pod replicas contant.
Create a replication controller No imperative command.
Example manifest:
1apiVersion: v1 2kind: ReplicationController 3metadata: 4 name: nginx 5 namespace: default 6 labels: 7 app: nginx 8spec: 9 replicas: 3 10 template: 11 metadata: 12 labels: 13 app: nginx 14 spec: 15 containers: 16 - name: nginx 17 image: docker.io/library/nginx:latest 18 imagePullPolicy: Never Resource output for a replication controller:</description>
    </item>
    
    <item>
      <title>ReplicaSet</title>
      <link>https://literate-devops.io/kubernetes/replicaset/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/replicaset/</guid>
      <description>A ReplicaSet ensures that there is always a stable number of pods based on the number of replicas.
Note: replicasets are very similar to replication controllers, with the exception that a replicaset can adopt pre-existing pods (using a selector).
Create a replicaset No imperative command.
Example manifest:
1apiVersion: apps/v1 2kind: ReplicaSet 3metadata: 4 name: nginx 5 namespace: default 6 labels: 7 app: nginx 8spec: 9 replicas: 3 10 selector: 11 matchLabels: 12 app: nginx 13 template: 14 metadata: 15 labels: 16 app: nginx 17 spec: 18 containers: 19 - name: nginx 20 image: docker.</description>
    </item>
    
    <item>
      <title>Deployment</title>
      <link>https://literate-devops.io/kubernetes/deployment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/deployment/</guid>
      <description>A deployment provides declaritive updates for Pods and Replicasets, with zero downtime and rolebacks - whenever necessary.
A deployment is the recommended way to deploy Kubernetes applications.
Create a deployment Imperative command:
kubectl create deployment $NAME --image=$IMAGE --namespace=default --replicas=3 Example manifest:
1apiVersion: apps/v1 2kind: Deployment 3metadata: 4 name: nginx 5 namespace: default 6 labels: 7 app: nginx 8spec: 9 replicas: 3 10 selector: 11 matchLabels: 12 app: nginx 13 template: 14 metadata: 15 labels: 16 app: nginx 17 spec: 18 containers: 19 - name: nginx 20 image: docker.</description>
    </item>
    
    <item>
      <title>Scaling</title>
      <link>https://literate-devops.io/kubernetes/scaling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/scaling/</guid>
      <description>To scale a replication controller, replicaset, statefulset, or deployment, use the kubectl scale command:
kubectl scale $RESOURCE/$NAME --filename=$FILE --namespace=default --replicas=$NUMBER Pitfall: this will not update the value for the replicas within the manifest.
Scale a deployment Imperative command:
kubectl scale deployments.apps/$NAME --replicas=$NUMBER deployment/$NAME --namespace=default Alternatively, update the number of replicas in the manifest and apply the changes using kubectl apply:
kubectl apply --filename=$FILE </description>
    </item>
    
    <item>
      <title>Port types</title>
      <link>https://literate-devops.io/kubernetes/port-types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/port-types/</guid>
      <description>Types of port found within a Kubernetes service:
Field Description targetPort Port on the pod port Port on the service nodePort Port on the node The ports are networked together like so:
LAN &amp;lt;--&amp;gt; nodePort|service|port &amp;lt;--&amp;gt; targetPort|pod </description>
    </item>
    
    <item>
      <title>NodePort</title>
      <link>https://literate-devops.io/kubernetes/nodeport/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/nodeport/</guid>
      <description>A NodePort service provides external access to Kubernetes applications by creating a listening port on each node in the cluster. You can connect to the service by simply using the port and IP addresses from one of these nodes.
Pitfall: nodeport can only use ports 30000 to 32767.
Create a nodeport service Imperative command:
kubectl create service nodeport $NAME --namespace=default --node-port=$NODEPORT --tcp=$PORT:$TARGETPORT Pitfall: the label selector on the service will have to be updated manually, since this command does not directly expose any application.</description>
    </item>
    
    <item>
      <title>ClusterIP</title>
      <link>https://literate-devops.io/kubernetes/clusterip/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/clusterip/</guid>
      <description>Since IP addresses for pods are transient, ClusterIP allows pods to communicate internally by providing a fixed IP address.
Create a clusterip service Imperative command:
kubectl create service clusterip $NAME --namespace=default --tcp=$PORT:$TARGETPORT Pitfall: the label selector on the service will have to be updated manually, since this command does not directly expose any application. Use the kubectl expose command if you want to have the labels set to the correct values automatically.</description>
    </item>
    
    <item>
      <title>Exposing</title>
      <link>https://literate-devops.io/kubernetes/exposing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/exposing/</guid>
      <description>Expose a Kubernetes object to a service.
Imperative command:
kubectl expose $RESOURCE/$NAME --name=$SERVICE_NAME --namespace=default --port=$PORT --protocol=TCP --selector=$LABELS --target-port=$PORT --type=$SERVICE_TYPE Pitfall: the kubectl expose command will not generate the nodePort field for you automatically, whereas kubectl create service nodeport will. Another difference between these two commands is that the expose command will fail if the resource does not exist beforehand, whereas the create command will not.
You can also use the --expose option with the kubectl run command, when you only need to expose a pod:</description>
    </item>
    
    <item>
      <title>LoadBalancer</title>
      <link>https://literate-devops.io/kubernetes/loadbalancer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/loadbalancer/</guid>
      <description>The LoadBalancer service is similar to a NodePort service, except that it is predominantly used with public cloud providers. The provider will be able to offer you an external load balancer that will go in front of this service.
Example load balancer configuration: offered by the Civo public cloud provider.
Note: Kubernetes already provides an internal load balancer when communicating with pods that are replicas.
Create a loadbalancer service Imperative command:</description>
    </item>
    
    <item>
      <title>Kubernetes documentation</title>
      <link>https://literate-devops.io/kubernetes/documentation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/documentation/</guid>
      <description>Use the kubectl explain command to output Kubernetes documentation for a particular resource.
Examples
Show the documentation for the ReplicaSet resource:
kubectl explain ReplicaSet | head --lines=10 Recursive output shows all nested fields within the resource:
kubectl explain ReplicaSet.spec --recursive </description>
    </item>
    
    <item>
      <title>Namespace</title>
      <link>https://literate-devops.io/kubernetes/namespace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/namespace/</guid>
      <description>A namespace is a mechanism to isolate groups of resources in a cluster.
Create a namespace Imperative command:
kubectl create namespace $NAME Example manifest:
apiVersion: v1 kind: Namespace metadata: name: dev Resource output for a namespace:
kubectl get namespaces/$NAME To change to a certain namespace, permanently:
kubectl config set-context --current --namespace=$NAME Show contexts to see what the current namespace is set to:
kubectl config get-contexts </description>
    </item>
    
    <item>
      <title>DNS</title>
      <link>https://literate-devops.io/kubernetes/dns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/dns/</guid>
      <description>You can get the FQDN for a service by connecting to one of its endpoints and checking the contents of resolv.conf:
kubectl exec pods/$NAME --namespace=$NAMESPACE -- /bin/cat /etc/resolv.conf The FQDN for Kubernetes services always has the form:
&amp;lt;my-service&amp;gt;.&amp;lt;namespace&amp;gt;.svc.&amp;lt;cluster-name&amp;gt; To connect to a service in a different namespace, use the FQDN, or the shorthand &amp;lt;my-service&amp;gt;.&amp;lt;namespace&amp;gt;.
To test connectiviy to a pod in a different namespace, you must always use the FQDN &amp;lt;my-pod&amp;gt;.</description>
    </item>
    
    <item>
      <title>Counting objects</title>
      <link>https://literate-devops.io/kubernetes/counting-objects/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/counting-objects/</guid>
      <description>To count the total number of objects in a resource (per namespace), use the --no-headers option and pipe the output to the wc --lines command:
kubectl get $RESOURCE --namespace=$NAMESPACE --no-headers | wc --lines </description>
    </item>
    
    <item>
      <title>Create command</title>
      <link>https://literate-devops.io/kubernetes/create-command/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/create-command/</guid>
      <description>To imperatively create a Kubernetes object using a manifest:
kubectl create --filename $FILE </description>
    </item>
    
    <item>
      <title>Edit command</title>
      <link>https://literate-devops.io/kubernetes/edit-command/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/edit-command/</guid>
      <description>To imperatively edit a Kubernetes object:
kubectl edit $RESOURCE/$NAME --namespace=$NAMESPACE The edit command is not advisable, since there exists no easy way to keep track of the changes made to a Kubernetes object (unless you are using annotations). But even with the existence of annotations, there still exists the issue of not having the changes reviewed (and approved). To fix this, use a revision control system, such as git, and make the changes there (in a manifest file that is under revision control).</description>
    </item>
    
    <item>
      <title>Replace command</title>
      <link>https://literate-devops.io/kubernetes/replace-command/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/replace-command/</guid>
      <description>To imperatively replace a Kubernetes object (with a new object):
kubectl replace --filename $FILE To completely delete and recreate an existing Kubernetes object:
kubectl replace --filename $FILE --force </description>
    </item>
    
    <item>
      <title>Apply command</title>
      <link>https://literate-devops.io/kubernetes/apply-command/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/apply-command/</guid>
      <description>The best way to create and make changes to a Kubernetes object is to use the declarative approach, via the apply command.
This approach allows you to create Kubernetes objects that can be updated when changes are made to their manifests without having to fully replace the Kubernetes objects like is with the case when using the imperative approach.
kubectl apply --filename $FILE </description>
    </item>
    
    <item>
      <title>Manual scheduling</title>
      <link>https://literate-devops.io/kubernetes/manual-scheduling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/manual-scheduling/</guid>
      <description>To ignore a scheduler completely and manually assign a pod to a node, use the nodeName field.
Example manifest:
1apiVersion: v1 2kind: Pod 3metadata: 4 name: nginx 5 namespace: default 6 labels: 7 app: nginx 8spec: 9 containers: 10 - name: nginx 11 image: nginx 12 nodeName: lab-cluster-worker2 </description>
    </item>
    
    <item>
      <title>Custom columns</title>
      <link>https://literate-devops.io/kubernetes/custom-columns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/custom-columns/</guid>
      <description>Custom columns allows you to customise table output.
Example custom-columns (using JSONPath syntax):
kubectl get pods --namespace=default --output=custom-columns=NAME:metadata.name,IP:status.podIP,NODE:spec.nodeName Output:
NAME IP NODE nginx-5ccbbcf759-28tlk 10.244.1.18 lab-cluster-worker2 nginx-5ccbbcf759-29dz5 10.244.2.11 lab-cluster-worker nginx-5ccbbcf759-w5k65 10.244.2.12 lab-cluster-worker </description>
    </item>
    
    <item>
      <title>Labels and Selectors</title>
      <link>https://literate-devops.io/kubernetes/labels-and-selectors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/labels-and-selectors/</guid>
      <description>Show output matching only the following labels:
kubectl get pods --selector=$LABEL1,$LABEL2,$LABEL3 Note: the comma syntax above refers to an AND statement.
To count the total number of objects that match a certain label:
kubectl get all --no-headers --selector=$LABEL | wc --lines </description>
    </item>
    
    <item>
      <title>Selectors</title>
      <link>https://literate-devops.io/kubernetes/selectors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/selectors/</guid>
      <description>Show output matching only the following labels:
kubectl get pods --selector=$LABEL1,$LABEL2,$LABEL3 Note: the comma syntax above refers to an AND statement.
To count the total number of objects that match a certain label:
kubectl get all --no-headers --selector=$LABEL | wc --lines </description>
    </item>
    
    <item>
      <title>Taints</title>
      <link>https://literate-devops.io/kubernetes/taints/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/taints/</guid>
      <description>Taint a node and mark it as non-schedulable:
kubectl taint nodes $NODE $LABEL:NoSchedule Add multiple taints to a node:
kubectl taint nodes $NODE $LABEL1:NoSchedule $LABEL2:NoSchedule Taint a node and prefer not to schedule any pods (without a toleration):
kubectl taint nodes $NODE $LABEL:PreferNoSchedule Taint a node and evict any pods (without a toleration):
kubectl taint nodes $NODE $LABEL:NoExecute View all taints on a particular node:
kubectl describe nodes/$NODE | grep Taints Remove a taint from a node:</description>
    </item>
    
    <item>
      <title>Tolerations</title>
      <link>https://literate-devops.io/kubernetes/tolerations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/tolerations/</guid>
      <description>A toleration allows a pod to be scheduled on any node with a matching taint.
Add tolerations to a pod Example manifest:
1apiVersion: v1 2kind: Pod 3metadata: 4 name: nginx 5 namespace: default 6 labels: 7 app: nginx 8spec: 9 tolerations: 10 - key: &amp;#34;app&amp;#34; 11 operator: &amp;#34;Equal&amp;#34; 12 value: &amp;#34;nginx&amp;#34; 13 effect: &amp;#34;NoSchedule&amp;#34; 14 - key: &amp;#34;gpu&amp;#34; 15 operator: &amp;#34;Exists&amp;#34; 16 effect: &amp;#34;NoSchedule&amp;#34; 17 containers: 18 - name: nginx 19 image: nginx Toleration operators:</description>
    </item>
    
    <item>
      <title>Labels</title>
      <link>https://literate-devops.io/kubernetes/labels/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/labels/</guid>
      <description>Labels are key-value pairs associated with Kubernetes objects. They allow the classification of objects, e.g. defining organisational structure.
List all labels associated with an object:
kubectl label nodes/$OBJECT --list List all labels associated with an object using the kubectl get command:
kubectl get $RESOURCE/$NAME --show-labels Count the total number of labels for an object:
kubectl label $RESOURCE/$OBJECT --list | wc --lines Add new labels:
kubectl label $RESOURCE/$OBJECT1 $LABEL1 $LABEL2 kubectl label $RESOURCE/$OBJECT2 $LABEL2 $LABEL3 Remove existing labels:</description>
    </item>
    
    <item>
      <title>nodeSelector</title>
      <link>https://literate-devops.io/kubernetes/nodeselector/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/nodeselector/</guid>
      <description>Schedule workloads on specific nodes.
Prerequisite: label nodes with special workloads, e.g. requires special hardware, such as a GPU.
Schedule a pod on a particular node (or set of nodes) using a nodeSelector.
Example manifest:
1apiVersion: v1 2kind: Pod 3metadata: 4 name: nginx 5 namespace: default 6 labels: 7 app: nginx 8spec: 9 containers: 10 - name: nginx 11 image: nginx 12 nodeSelector: 13 compute: large </description>
    </item>
    
    <item>
      <title>Node affinity</title>
      <link>https://literate-devops.io/kubernetes/nodeaffinity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/nodeaffinity/</guid>
      <description>Node affinity affects what nodes a pod can be scheduled on, using a selection of labels and operator logic.
Example manifest:
1apiVersion: v1 2kind: Pod 3metadata: 4 name: nginx 5 namespace: default 6 labels: 7 app: nginx 8spec: 9 containers: 10 - name: nginx 11 image: nginx 12 affinity: 13 nodeAffinity: 14 requiredDuringSchedulingIgnoredDuringExecution: 15 nodeSelectorTerms: 16 - matchExpressions: 17 - key: compute 18 operator: In 19 values: 20 - large 21 - medium 22 - key: compute 23 operator: NotIn 24 values: 25 - small 26 - key: gpu 27 operator: Exists 28 - key: quantum 29 operator: DoesNotExist CKA Exam Tip: node affinity requires that you reference the kubernetes.</description>
    </item>
    
    <item>
      <title>ResourceQuota</title>
      <link>https://literate-devops.io/kubernetes/resourcequota/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/resourcequota/</guid>
      <description>Limit aggregate resource consumption per namespace.
Create a namespace-scoped resource quota Imperative command:
kubectl create quota $NAME --hard=persistentvolumeclaims=10,pods=10,replicationcontrollers=2,resourcequotas=2,secrets=10,services=2,limits.cpu=500m,limits.memory=2048Mi,requests.cpu=250m,requests.memory=1024Mi --namespace=$NAMESPACE Example manifest:
1apiVersion: v1 2kind: ResourceQuota 3metadata: 4 name: dev-quota 5 namespace: dev 6spec: 7 hard: 8 persistentvolumeclaims: &amp;#34;10&amp;#34; 9 pods: &amp;#34;10&amp;#34; 10 replicationcontrollers: &amp;#34;2&amp;#34; 11 resourcequotas: &amp;#34;2&amp;#34; 12 secrets: &amp;#34;10&amp;#34; 13 services: &amp;#34;2&amp;#34; 14 limits.cpu: 500m 15 limits.memory: 2Gi 16 requests.cpu: 250m 17 requests.memory: 1Gi CKA Exam Tip: resource quotas require that you reference the kubernetes.</description>
    </item>
    
    <item>
      <title>Default resource limits and requests</title>
      <link>https://literate-devops.io/kubernetes/default-resource-limits-and-requests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/kubernetes/default-resource-limits-and-requests/</guid>
      <description>When a pod exceeds its CPU limit, it gets throttled. When a pod exceeds its memory limit, it is not immediately terminated. Only if a pod continuously exceeds its memory limit is it terminated.
The default limits and requests for a pod are used when no resource requirements have been defined within the spec. This can useful when you have a resource quota applied to the same namespace as the pod.</description>
    </item>
    
    <item>
      <title>Curriculum Vitae</title>
      <link>https://literate-devops.io/cv/</link>
      <pubDate>Tue, 18 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://literate-devops.io/cv/</guid>
      <description> Education Academic qualifications.
College A-levels.
University Degree qualification.
Employment Employment history.
Sabbatical </description>
    </item>
    
  </channel>
</rss>
